from flask import Flask, redirect, render_template, request, jsonify, session
from flask_socketio import SocketIO
from flask_sqlalchemy import SQLAlchemy
from flask_bcrypt import Bcrypt
import os
import requests
from werkzeug.utils import secure_filename

# Initialize Flask app
app = Flask(__name__)
app.config['SECRET_KEY'] = 'your_secret_key'

# Initialize extensions
socketio = SocketIO(app)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'  # SQLite for simplicity
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)
bcrypt = Bcrypt(app)

# Upload configuration
app.config['UPLOAD_FOLDER'] = './uploads'
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg'}
MAX_FILE_SIZE = 5 * 1024 * 1024  # 5MB limit
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)

# Hugging Face API configuration
API_URL = "https://api-inference.huggingface.co/models/nlpconnect/vit-gpt2-image-captioning"
HEADERS = {"Authorization": "Bearer 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"}

# Groq API configuration (Assumed to be available)
try:
    from groq import Groq
    client = Groq(api_key='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')  # Replace with your Groq API key
except Exception as e:
    print(f"Error initializing Groq client: {e}")
    client = None

# Models
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(150), unique=True, nullable=False)
    email = db.Column(db.String(150), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)

class Chat(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    prompt = db.Column(db.Text, nullable=False)
    response = db.Column(db.Text, nullable=False)

# Create tables
with app.app_context():
    db.create_all()

# Helper functions
def allowed_file(filename):
    """Check if the file has an allowed extension."""
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def query_huggingface(filename):
    """Send an image to the Hugging Face API and return the response."""
    try:
        # Open the image and send it to Hugging Face API
        with open(filename, "rb") as f:
            response = requests.post(API_URL, headers=HEADERS, data=f.read())

        # Check if the API responded successfully
        response.raise_for_status()  # Raises an HTTPError for non-2xx responses

        response_json = response.json()
        print(f"Response JSON: {response_json}")  # Log the complete response for analysis

        # Check if the response is a list and contains 'generated_text'
        if isinstance(response_json, list) and len(response_json) > 0:
            caption = response_json[0].get('generated_text')
            if caption:
                return {"caption": caption}  # Successfully generated caption
            else:
                return {"error": "No caption generated by the model. The image may not be suitable."}
        else:
            return {"error": "Invalid response format from Hugging Face API. Expected a list with caption."}

    except requests.exceptions.RequestException as e:
        print(f"Error during API call: {e}")
        return {"error": f"Request error: {str(e)}"}
    except ValueError as e:
        print(f"Error parsing JSON response: {e}")
        return {"error": "Invalid response format from Hugging Face API"}

def generate_request(user_input):
    """Generates a response based on user input using Groq API."""
    if not client:
        return "Error: Groq client not initialized."
    
    chat_completion = client.chat.completions.create(
        messages=[{"role": "system", "content": "Respond to the input with relevant content in any appropriate format."},
                  {"role": "user", "content": user_input}],
        model="llama3-70b-8192"
    )
    return chat_completion.choices[0].message.content

# Routes

@app.route('/')
def index():
    """Render the login page."""
    return render_template('login.html')

@app.route('/index')
def main_page():
    """Render the main page if the user is logged in."""
    if 'user_id' not in session:
        return redirect('/')
    return render_template('index.html')

@app.route('/signup', methods=['POST'])
def signup():
    """Register a new user."""
    username = request.json.get('username')
    email = request.json.get('email')
    password = request.json.get('password')

    if User.query.filter_by(email=email).first():
        return jsonify({"error": "Email already registered!"}), 400

    hashed_password = bcrypt.generate_password_hash(password).decode('utf-8')
    new_user = User(username=username, email=email, password=hashed_password)
    db.session.add(new_user)
    db.session.commit()

    return jsonify({"message": "User created successfully!"}), 200

@app.route('/login', methods=['POST'])
def login():
    """Log in a user."""
    email = request.json.get('email')
    password = request.json.get('password')

    user = User.query.filter_by(email=email).first()
    if user and bcrypt.check_password_hash(user.password, password):
        session['user_id'] = user.id
        session['username'] = user.username
        return jsonify({"message": "Login successful!"}), 200

    return jsonify({"error": "Invalid credentials!"}), 400

@app.route('/logout')
def logout():
    """Log out the user."""
    session.pop('user_id', None)
    session.pop('username', None)
    return redirect('/')

@app.route('/upload_image', methods=['POST'])
def upload_image():
    """Handle image uploads and return captions."""
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400

    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400

    if not allowed_file(file.filename):
        return jsonify({"error": "Invalid file type"}), 400

    # Save file
    filename = secure_filename(file.filename)
    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    file.save(filepath)

    try:
        # Send to Hugging Face API
        output = query_huggingface(filepath)
        if "caption" in output:
            return jsonify({"caption": output["caption"]}), 200
        else:
            return jsonify({"error": output.get("error", "Unknown error occurred")}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/get_response', methods=['POST'])
def get_response():
    """Generate a response using Groq API and save it to chat history."""
    if 'user_id' not in session:
        return jsonify({"error": "Unauthorized"}), 401

    user_id = session['user_id']
    user_input = request.json.get('user_input')
    incognito = request.json.get('incognito', False)

    if not user_input:
        return jsonify({"error": "No input provided"}), 400

    try:
        # Generate new response using Groq
        response = generate_request(user_input)

        # Save the new chat to the database if not in incognito mode
        if not incognito:
            new_chat = Chat(user_id=user_id, prompt=user_input, response=response)
            db.session.add(new_chat)
            db.session.commit()

        return jsonify({"response": response})
    except Exception as e:
        return jsonify({"error": f"Failed to process request: {e}"}), 500

@app.route('/get_chat_history', methods=['GET'])
def get_chat_history():
    """Retrieve chat history for the logged-in user."""
    if 'user_id' not in session:
        return jsonify({"error": "Unauthorized"}), 401

    user_id = session['user_id']
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)

    chats = Chat.query.filter_by(user_id=user_id).paginate(page=page, per_page=per_page)
    chat_history = [{"prompt": chat.prompt, "response": chat.response} for chat in chats.items]

    return jsonify({
        "chats": chat_history,
        "total_pages": chats.pages,
        "current_page": chats.page
    }), 200

@app.route('/clear_chat_history', methods=['DELETE'])
def clear_chat_history():
    """Clear chat history for the logged-in user."""
    if 'user_id' not in session:
        return jsonify({"error": "Unauthorized"}), 401

    user_id = session['user_id']
    try:
        Chat.query.filter_by(user_id=user_id).delete()
        db.session.commit()
        return jsonify({"message": "Chat history cleared successfully!"}), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500
@app.route('/search_chat_history', methods=['GET'])
def search_chat_history():
    if 'user_id' not in session:
        return jsonify({"error": "Unauthorized"}), 401

    user_id = session['user_id']
    query = request.args.get('query', '', type=str)

    try:
        # If query is empty, fetch all chats for the user
        if not query:
            chats = Chat.query.filter_by(user_id=user_id).all()
        else:
            # If query is provided, filter based on the prompt or response
            chats = Chat.query.filter(
                Chat.user_id == user_id,
                (Chat.prompt.ilike(f"%{query}%") | Chat.response.ilike(f"%{query}%"))
            ).all()

        if not chats:
            message = "No matching chats found." if query else "No chats available."
            return jsonify({"chats": [], "message": message}), 200

        chat_history = [{"prompt": chat.prompt, "response": chat.response} for chat in chats]
        return jsonify({"chats": chat_history}), 200

    except Exception as e:
        return jsonify({"error": f"An error occurred: {str(e)}"}), 500

@app.route('/delete_chat', methods=['DELETE'])
def delete_chat():
    """Delete a specific chat."""
    if 'user_id' not in session:
        return jsonify({"error": "Unauthorized"}), 401

    chat_id = request.json.get('chat_id')
    try:
        chat = Chat.query.filter_by(id=chat_id, user_id=session['user_id']).first()
        if chat:
            db.session.delete(chat)
            db.session.commit()
            return jsonify({"message": "Chat deleted successfully!"}), 200
        else:
            return jsonify({"error": "Chat not found!"}), 404
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    socketio.run(app, host='0.0.0.0', debug=True)
